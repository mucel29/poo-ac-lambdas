
<!DOCTYPE html>
<html>
  <head>
    <title>no title</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    .markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}code[class*=language-],pre[class*=language-]{color:#c9d1d9;text-shadow:none;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::mozselection,code[class*=language-]::selection,pre[class*=language-]::mozselection,pre[class*=language-]::selection{text-shadow:none;background:#234879}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;background:#161b22}:not(pre)>code[class*=language-]{padding:.1em .3em;border-radius:.3em;color:#c9d1d9;background:#343942}pre[data-line]{position:relative}pre[class*=language-]>code[class*=language-]{position:relative;z-index:1}.line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:#2f2a1e;box-shadow:inset 5px 0 0 #674c16;z-index:0;pointer-events:none;line-height:inherit;white-space:pre}.namespace{opacity:.7}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8b949e}.token.punctuation{color:#c9d1d9}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#79c0ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a5d6ff}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#a5d6ff}.token.atrule,.token.attr-value,.token.keyword{color:#f97583}.token.function{color:#d2a8ff}.token.important,.token.regex,.token.variable{color:#79b8ff}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.emoji{height:.8em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#ccc;background-color:#24292e;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#fff}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#a3a3a3}html body strong{color:#fff}html body del{color:#a3a3a3}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#a3a3a3;background-color:#363d45;border-left:4px solid #48525c}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#48525c;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#fff}html body table td,html body table th{border:1px solid #48525c;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#fff;background-color:#363d45;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#48525c;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#fff;border:1px solid #48525c;border-bottom:2px solid #3a424b;padding:2px 4px;background-color:#363d45;border-radius:3px}@media print{html body{background-color:#24292e}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#fff;page-break-after:avoid}html body blockquote{color:#a3a3a3}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}
    /* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

    </style>
    
    <!-- The content below will be included at the end of the <head> element. --><html><head><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body></body></html>
  </head>
  <body for="html-export">
    <div class="crossnote markdown-preview">
    <html><head></head><body><div>
<h1 id="poo---extra-1---functii-lambda---omit-from-toc--" ebook-toc-level-1="" heading="POO - Extra 1 - Functii lambda <!-- omit from toc --> ">POO - Extra 1 - Functii lambda <!-- omit from toc --> </h1>
<br>
<ul>
<li><a href="#introducere-in-programarea-functionala">Introducere in programarea functionala</a>
<ul>
<li><a href="#motivare">Motivare</a></li>
<li><a href="#de-ce-primele-limbaje-erau-bazate-pe-modelul-lui-turing">De ce primele limbaje erau bazate pe modelul lui Turing</a></li>
<li><a href="#limbaje-de-programare-functionale">Limbaje de programare functionale</a></li>
<li><a href="#influenta-asupra-celorlalte-limbaje">Influenta asupra celorlalte limbaje</a></li>
<li><a href="#concepte">Concepte</a></li>
</ul>
</li>
<li><a href="#programarea-functionala-in-c">Programarea functionala in <code>C++</code></a>
<ul>
<li><a href="#function-pointers">Function pointers</a></li>
<li><a href="#function-objects">Function objects</a></li>
<li><a href="#lambda-functions">Lambda functions</a></li>
<li><a href="#la-ce-putem-folosi-functiile-lambda-in-c">La ce putem folosi functiile lambda in C++</a></li>
</ul>
</li>
<li><a href="#concluzii">Concluzii</a></li>
</ul>
<br>
<h2 id="introducere-in-programarea-functionala" ebook-toc-level-2="" heading="Introducere in programarea functionala ">Introducere in programarea functionala </h2>
<p>Asa cum anul trecut ati invatat despre programarea procedurala, care apartine paradigmei imperative, anul acesta veti studia paradigma orientata obiect. Pe langa aceste 2 paradigme, mai exista si paradigma functionala.</p>
<p>Dupa cum reiese si din numele acesteia, blocul de baza in aceasta paradigma este functia.</p>
<blockquote>
<p>Mai pe scurt, <strong>totul este o functie</strong>.</p>
</blockquote>
<br>
<h3 id="motivare" ebook-toc-level-3="" heading="Motivare ">Motivare </h3>
<p>Cu mult timp in urma, pe cand programarea era doar o extensie a matematicii, <code>Alan Turing</code> a propus un model de calcul numit <code>Masina Turing</code> care sta la baza limbajelor pe care le-ati invatat pana acum.</p>
<p>In acelasi timp cu Turing, un alt matematician pe nume <code>Alonzo Church</code> propune un model de calcul ceva mai matematic, numit <code>calcul lambda</code>.</p>
<p>Dupa ce Turing si Church au aflat despre similaritatea modelelor lor, impreuna cu <code>Kleene</code> au scris <code>Teza Church-Turing</code> care demonstreaza ca, de fapt, cele doua modele de calcul sunt echivalente.</p>
<blockquote>
<p>Pe scurt, <code>Alan Turing</code> si <code>Alonzo Church</code> au venit amandoi cu 2 modele care pot fi interschimbate. Orice program acceptat de o <code>Masina Turing</code> poate fi implementat folosind <code>calculul lambda</code> si vice-versa.</p>
</blockquote>
<br>
<h3 id="de-ce-primele-limbaje-erau-bazate-pe-modelul-lui-turing" ebook-toc-level-3="" heading="De ce primele limbaje erau bazate pe modelul lui Turing ">De ce primele limbaje erau bazate pe modelul lui Turing </h3>
<p>Majoritatea primelor limbaje de programare aveau la baza modelul propus de Turing, acesta fiind considerate <code>Turing complete</code>. Acest lucru se datoreaza dificultatii simularii calcului lambda, care are la baza mecanisme precum <code>recursivitatea</code>. Resursele hardware fiind limitate la acea vreme, nu era fezabila o recursivitate mai mare de cateva nivele.</p>
<br>
<h3 id="limbaje-de-programare-functionale" ebook-toc-level-3="" heading="Limbaje de programare functionale ">Limbaje de programare functionale </h3>
<p>Astazi, hardware-ul din ce in ce mai bun, ne-a permis sa exploram si "geamanul" masinii Turing, ducand la aparitia limbajelor functionale.</p>
<p>Cateva limbaje ce se incadreaza in paradigma functionala:</p>
<ul>
<li><code>Haskell</code> — pur functional, cel mai reprezentativ</li>
<li><code>Scala</code> — functional si orientat obiect, ruleaza pe JVM</li>
<li><code>OCaml</code> — functional si orientat obiect</li>
<li><code>F#</code> — normal ca si Microsoft trebuia sa faca ceva</li>
<li><code>Elixir</code> — functional, ruleaza pe ErlangVM</li>
</ul>
<br>
<h3 id="influenta-asupra-celorlalte-limbaje" ebook-toc-level-3="" heading="Influenta asupra celorlalte limbaje ">Influenta asupra celorlalte limbaje </h3>
<p>Data fiind utilitatea paradigmei, majoritatea limbajelor implementeaza intr-o oarecare masura conceptele acesteia.</p>
<blockquote>
<p><strong>Java</strong></p>
<p>In <code>Java</code>, paradigma functionala isi face simtita prezenta prin utilizarea <code>claselor anonime</code>, in special cele anotate cu <code>@FunctionalInterface</code></p>
<p>Exemplu</p>
<pre data-role="codeBlock" data-info="java" class="language-java java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> a<span class="token punctuation">,</span> <span class="token class-name">Integer</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>Aici, metoda <code>sort</code> are ca argument o clasa anonima de tipul <code>Comparator&lt;Integer&gt;</code> care ne compara 2 elemente din lista pentru a ne determina ordinea acestora.</p>
<ul>
<li><code>(Integer a, Integer b)</code> — parametrii functiei</li>
<li><code>a - b</code> — corpul functiei, echivalent cu <code>return a - b;</code></li>
</ul>
</blockquote>
<br>
<blockquote>
<p><strong>JavaScript</strong></p>
<p>In <code>JavaScript</code>, programarea functionala este folosita prin intermediul <code>arrow functions</code>, acestea putand fi stocate in variabile si apelate mai tarziu.</p>
<p>Exemplu</p>
<pre data-role="codeBlock" data-info="js" class="language-javascript js"><code><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
</code></pre><p>Aici, mesajul <code>Hello, World!</code> este printat la un interval de 2 secunde.</p>
<ul>
<li><code>()</code> — parametrii functiei</li>
<li><code>{console.log(...);}</code> — corpul functiei</li>
</ul>
</blockquote>
<br>
<blockquote>
<p><strong>Python</strong></p>
<p>In <code>Python</code>, putem pasa functiile definite de noi altei functii <em>(vezi <a href="#concepte">functii de ordin superior</a>)</em>, sau prin cuvantul cheie <code>lambda</code></p>
<p>Exemplu 1</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword keyword-def">def</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword keyword-print">print</span><span class="token punctuation">(</span><span class="token string">"I am fun1"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword keyword-def">def</span> <span class="token function">other</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   function<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> other<span class="token punctuation">(</span>fun1<span class="token punctuation">)</span>
I am fun1
</code></pre><p>Aici, am apelat functia <code>other</code> folosind <code>fun1</code> ca parametru, care mai departe este apelata de catre <code>other</code> si ne printeaza <code>I am fun1</code></p>
<br>
<p>Exemplu 2</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword keyword-def">def</span> <span class="token function">apply</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword keyword-print">print</span><span class="token punctuation">(</span>fun<span class="token punctuation">(</span><span class="token string">"Just a normal string"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">apply</span><span class="token punctuation">(</span><span class="token keyword keyword-lambda">lambda</span> s<span class="token punctuation">:</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
gnirts lamron a tsuJ
</code></pre><p>Aici, am pasat catre <code>apply</code> functia definita cu <code>lambda</code> care ne inverseaza sirul de caractere primit ca input. <code>apply</code> apeleaza lambda-ul primit ca parametru cu sirul <code>Just a normal string</code> si printeaza rezultatul.</p>
<ul>
<li><code>lambda</code> — cuvantul cheie pentru a defini o functie lambda</li>
<li><code>s</code> — parametrul functiei</li>
<li><code>:</code> — separa parametrii de corpul functiei</li>
<li><code>s[::-1]</code> — corpul functiei, inverseaza sirul primit</li>
</ul>
</blockquote>
<br>
<h3 id="concepte" ebook-toc-level-3="" heading="Concepte ">Concepte </h3>
<p>Pentru a putea utiliza eficient paradigma functionala, trebuie sa cunoastem cateva concepte pe care le putem aplica in codul nostru.</p>
<blockquote>
<p><strong>Concepte cheie</strong><br>
Aceste concepte se aplica mai mult in limbajele functionale, acestea fiind adesea incalcate in cele <code>multi-paradigm</code></p>
<ul>
<li>
<p><code>Functii pure</code> — o functie pura trebuie sa produca acelasi rezultat pentru acelasi input; fara efecte laterale</p>
</li>
<li>
<p><code>Imutabilitatea</code> — datele, odata create, nu pot fi modificate; putem crea o structura noua cu datele pe care vrem sa le modificam</p>
</li>
<li>
<p><code>Efectele laterale</code> — nu putem interactiona cu lumea exterioara:</p>
</li>
<li>
<ul>
<li>modificarea inputul <em>(mutation)</em></li>
</ul>
</li>
<li>
<ul>
<li>scrierea intr-un fisier sau in consola</li>
</ul>
</li>
<li>
<ul>
<li>modificarea unei variabile externe <em>(globale)</em></li>
</ul>
</li>
<li>
<ul>
<li>aruncarea exceptiilor</li>
</ul>
</li>
</ul>
</blockquote>
<br>
<blockquote>
<p><strong>Aspecte functionale</strong><br>
Aceste concepte se refera strict la reprezentarea si utilizarea functiilor in contextul programarii functionale:</p>
<ul>
<li>
<p><code>Functii de prima clasa</code> — o functie poate:</p>
</li>
<li>
<ul>
<li>fi stocata intr-o variabila</li>
</ul>
</li>
<li>
<ul>
<li>pasata ca argument altei functii</li>
</ul>
</li>
<li>
<ul>
<li>intoarsa de catre alta functie</li>
</ul>
</li>
<li>
<p><code>Functii de ordin superior</code> — aceste functii pot:</p>
</li>
<li>
<ul>
<li>sa accepte alte functii ca parametrii</li>
</ul>
</li>
<li>
<ul>
<li>sa intoarca alta functie</li>
</ul>
</li>
<li>
<blockquote>
<p>Exemple: <code>map</code> <em>(<code>std::transform</code>)</em>, <code>filter</code> <em>(<code>std::copy_if</code>)</em>, <code>reduce</code> <em>(<code>std::accumulate</code>)</em></p>
</blockquote>
</li>
<li>
<p><code>Compunere functionala</code> — inlantuirea functiilor prin compunere matematica <code>h(x) = f(g(x))</code></p>
</li>
<li>
<p><code>Currying</code> — scrierea functiilor cu parametrii multiplii ca apelari succesive cu fiecare parametru <code>f(a, b, c) = f(a)(b)(c)</code></p>
</li>
<li>
<p><code>Aplicare partiala</code> — fixarea argumentelor unei functii si intoarcerea restului spre completare <code>g =&gt; f(1)(2)</code> mai tarziu va fi apelata <code>g(x) = f(1)(2)(x)</code></p>
</li>
</ul>
</blockquote>
<br>
<blockquote>
<p><strong>Concepte abstracte</strong></p>
<p>Aceste concepte ne ajuta sa gandim un program imperativ intr-un stil functional</p>
<ul>
<li><code>Recursivitatea</code> — orice structura repetitiva este inlocuita de recursivitate care ruleaza pana cand un <code>caz de baza</code> este atins.</li>
</ul>
<p>Majoritatea limbajelor moderne implementeaza o optimizare numita <code>Tail recursion</code> care refoloseste stiva apelului anterior pentru a evita <code>stack overflow</code>-ul.</p>
</blockquote>
<br>
<h2 id="programarea-functionala-in-c" ebook-toc-level-2="" heading="Programarea functionala in <code>C++</code> ">Programarea functionala in <code>C++</code> </h2>
<p>In <code>C++</code> putem folosi mecanismele programarii functionale prin 3 moduri:</p>
<ul>
<li><code>function pointers</code> — mostenite din <code>C</code></li>
<li><code>function objects</code> <em>(functors)</em> — folosite inainte de <code>C++11</code></li>
<li><code>std::function</code> <em>(lambda functions)</em> — adaugate in <code>C++11</code></li>
</ul>
<br>
<h3 id="function-pointers" ebook-toc-level-3="" heading="Function pointers ">Function pointers </h3>
<p>Dupa cum ne spune si numele, pasam un pointer <em>(aratator)</em> functiei care vrea sa aplica operatie definita de noi</p>
<blockquote>
<p>Exemplu 1 <em>(sortare)</em></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">comp</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

  <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Aici ne definim functia de comparare <code>comp</code> care primeste 2 <code>void *</code> <em>(asa functioneaza <code>qsort</code>, e generic)</em> pentru a-i compara.</p>
<p>Apelam <code>qsort</code> cu urmatorii parametrii:</p>
<ul>
<li><code>arr</code> — vectorul de sortat</li>
<li><code>n</code> — numarul de elemente</li>
<li><code>sizeof(int)</code> — dimensiunea <em>(stride)</em> unui element din vector</li>
<li><code>comp</code> — functia de comparare</li>
</ul>
</blockquote>
<br>
<blockquote>
<p>Exemplu 2 <em>(threading)</em></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> thread_id <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from thread %d\n"</span><span class="token punctuation">,</span> thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>
  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thread_func<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Aici, definim functia care va fi executata intr-un alt fir de executie, in paralel prin <code>thread_func</code>. In main ne cream firul de executie prin <code>pthread_create</code>, pasand functia noastra ca al 3-lea argument si <code>0</code> ca id-ul nostru <em>(<code>arg</code> in functie)</em></p>
</blockquote>
<br>
<h3 id="function-objects" ebook-toc-level-3="" heading="Function objects ">Function objects </h3>
<p>Functiile obiect, sau functori, sunt metoda veche de a folosi programarea pentru a sorta un vector de exemplu:</p>
<blockquote>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">MyComparator</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-return">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  size_t n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  
  std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> numbers <span class="token operator">+</span> n<span class="token punctuation">,</span> <span class="token function">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Aici, definim un <code>struct</code> special numit <code>MyComparator</code> unde ii supraincarcam opratorul de apelare care va primi 2 numere <code>a</code> si <code>b</code> si va intoarce daca a este mai mic decat b.<br>
In main, apelam <code>std::sort</code> cu inceputul si sfarsitul vectorului, urmat de o instanta de <code>MyComparator</code></p>
</blockquote>
<br>
<h3 id="lambda-functions" ebook-toc-level-3="" heading="Lambda functions ">Lambda functions </h3>
<p>Din <code>C++11</code> avem la dispozitie tipul <code>std::function</code> care ne permite sa repzentam o functie de prima clasa, astfel putand sa o stocam ca o variabila sau parametru altei functii.</p>
<blockquote>
<p><strong>Declarare</strong></p>
<p>Pentru a nu avea probleme de compilare, tipul variabilei / parametrului trebuie sa fie de forma</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token function">tip_return</span><span class="token punctuation">(</span>tip_parametru1<span class="token punctuation">,</span> tip_parametru2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
</code></pre><p>Pentru acest laborator, vom folosi <code>auto</code> pentru parametrii de functie, iar variabilele vor avea deja tipul corect. <em>(veti afla mai multe despre tipurile sablon la cursul de <code>STL</code>)</em></p>
<p>Avand in vedere cele mentionate mai sus, putem declara o functie lambda in felul urmator:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-auto">auto</span> my_fun <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword keyword-bool">bool</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Componentele declararii sunt:</p>
<ul>
<li><code>[]</code> — captura <em>(mai multe detalii mai jos)</em></li>
<li><code>(int a, int b)</code> — parametrii functiei</li>
<li><code>-&gt;</code> — separator</li>
<li><code>bool</code> — tipul intors de functie</li>
<li><code>{return a &lt; b;}</code> — corpul functiei</li>
</ul>
<p><em>Separatorul si tipul de return pot fi omise, compilatorul deducandu-le</em></p>
</blockquote>
<br>
<blockquote>
<p><strong>Capturi</strong></p>
<p>Cum ati vazut si mai sus, cand ne declaram functia lambda, trebuie sa folosim <code>[]</code> altfel vom primi eroare de compilare.</p>
<p>Aceste paranteze reprezinta captura functiei noastre, adica ce "luam din afara"</p>
<p>Fie urmatorul exemplu:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-float">float</span> y <span class="token operator">=</span> <span class="token number">.5f</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-double">double</span> z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">,</span> w <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
  
  <span class="token keyword keyword-auto">auto</span> my_fun1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// Do something here</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-auto">auto</span> my_fun2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// Do something here</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><p>Aici, putem observa diferite tipuri de capturi de le putem aplica:</p>
<ul>
<li><code>[=]</code> — toate variabilele externe sunt accesibile ca si copii in corpul functiei</li>
<li><code>[&amp;]</code> — toate variabilele externe sunt accesibile ca si referinte in corpul functiei</li>
<li><code>[=, &amp;x]</code> — toate variabilele externe sunt copiate, mai butin x care este luat ca referinta</li>
<li><code>[&amp;, y, z]</code> — toate variabilele externe sunt luate ca referinta, mai putin y si z care sunt copiate</li>
</ul>
<p>Putem extinde captura cum vrei noi, adaugand variabile in lista capturii</p>
<p>Acest lucru ne permite sa producem <code>efecte laterale</code></p>
</blockquote>
<br>
<h3 id="la-ce-putem-folosi-functiile-lambda-in-c" ebook-toc-level-3="" heading="La ce putem folosi functiile lambda in C++ ">La ce putem folosi functiile lambda in C++ </h3>
<blockquote>
<p><strong>Modificarea comportamentului</strong></p>
<p>Folosindu-ne de proprietatea de prima clasa a functiilor de tipul <code>std::function</code> putem modifica comportamentul unei instante fara a mai fi nevoie sa derivam o clasa noua care sa ii suprascrie metodele.</p>
<p>Exemplu</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-private">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> behaviour<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>

  <span class="token comment">// Nota: tipul de parametru auto functioneaza din C++20</span>
  <span class="token keyword keyword-void">void</span> <span class="token function">setBehaviour</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token operator">&amp;</span> behaviour<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-this">this</span><span class="token operator">-&gt;</span>behaviour <span class="token operator">=</span> behaviour<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword keyword-void">void</span> <span class="token function">doBehaviour</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword keyword-this">this</span><span class="token operator">-&gt;</span>behaviour<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"Behaviour not set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword keyword-this">this</span><span class="token operator">-&gt;</span><span class="token function">behaviour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-auto">auto</span> my_behaviour1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Behaviour1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  MyClass my_instance<span class="token punctuation">;</span>

  my_instance<span class="token punctuation">.</span><span class="token function">setBehaviour</span><span class="token punctuation">(</span>my_behaviour1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  my_instance<span class="token punctuation">.</span><span class="token function">doBehaviour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// printeaza Behaviour1</span>

  my_instance<span class="token punctuation">.</span><span class="token function">setBehaviour</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>counter<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Counter: "</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
      counter<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  my_instance<span class="token punctuation">.</span><span class="token function">doBehaviour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// printeaza Counter: 0</span>
  my_instance<span class="token punctuation">.</span><span class="token function">doBehaviour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// printeaza Counter: 1</span>
<span class="token punctuation">}</span>
</code></pre><p>Aici, practic am schimbat comportamentul instantei <code>my_instance</code> din a printa <code>Behaviour1</code> in a printa un contor si a-l incrementa folosindu-ne de captura prin referinta a variabilei <code>counter</code>.</p>
<p>Also, codul de mai sus descrie un <code>Design Pattern</code> — <code>Strategy</code> <em>(mai multe la curs)</em></p>
</blockquote>
<br>
<blockquote>
<p><strong>Operatii pe siruri</strong></p>
<p>Prin aceleasi mecanisme putem:</p>
<ul>
<li>sorta un sir — <code>std::sort</code></li>
<li>filtra un sir — <code>std::copy_if</code> sau <code>std::ranges::views::filter</code></li>
<li>mapa un sir intr-un alt sir — <code>std::transform</code></li>
<li>
<ul>
<li><em>(exemplu: incrementarea elementelor)</em></li>
</ul>
</li>
<li>reducerea sirului la o singura valoare — <code>std::accumulate</code></li>
<li>
<ul>
<li><em>(exemplu: suma tuturor elementelor)</em></li>
</ul>
</li>
</ul>
</blockquote>
<br>
<h2 id="concluzii" ebook-toc-level-2="" heading="Concluzii ">Concluzii </h2>
<p>Paradigma functionala este un subiect destul de aplu despre care se poate vorbi <em>(sau eu cel putin pot vorbi)</em> foarte mult, dar cate poti face intr-un laborator...</p>
<p>Cu toate acestea, sper ca am reusit sa va intrig cu aceasta paradigma noua.</p>
<p>Pentru cei interesati, exista cursul de <code>Paradigme de Programare</code> <em>(CTI — anul 2, semestrul 2)</em> unde se studiaza diverse paradigme <em>(functionala, orientata obiect, logica)</em>. Material se gaseste pe <code>ocw</code> <em>(Seriile CA, CB si CC)</em> si pe <code>ppcarte</code> <em>(Seria CD)</em>.</p>
</div></body></html>
    </div>
  </body>
</html>
